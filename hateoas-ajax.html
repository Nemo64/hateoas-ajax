<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-ajax/iron-ajax-behavior.html"/>

<dom-module id="hateoas-ajax">
    <script>
//        var oldFire = Polymer.Base.fire;
//        Polymer.Base.fire = function () { console.log(arguments); oldFire.apply(this, arguments); };

        //noinspection JSUnusedGlobalSymbols
        Polymer({
            is: 'hateoas-ajax',

            // we want iron ajax behavior
            behaviors: [Polymer.IronAjaxBehavior],

            properties: {

                linkProperty: {
                    type: String,
                    value: '_links'
                },

                embeddedProperty: {
                    type: String,
                    value: '_embedded'
                },

                /**
                 * This map remembers all <hateoas-ajax> elements to reusing for get requests with the same uri
                 */
                _requestsByUri: {
                    type: Object,
                    value: function () { return {} }
                }
            },

            observers: [
                '_process(lastResponse)'
            ],

            createSubInstance: function () {
                var request = document.createElement(this.nodeName);
                request.linkProperty = this.linkProperty;
                request.embeddedProperty = this.embeddedProperty;
                request.headers = this.headers;
                request.auto = false;
                request._requestsByUri = this._requestsByUri;
                return request;
            },

            _process: function (value) {
                if (value.__doNotProcess__) {
                    return;
                }

                if (value instanceof Array) {
                    value = value.map(this._modifyObject, this);
                } else if (value instanceof Object) {
                    value = this._modifyObject(value);
                }

                // prevent this value to be processed again while setting
                value.__doNotProcess__ = true;
                this._setLastResponse(value);
                delete value.__doNotProcess__;
            },

            _modifyObject: function (object, index) {
                var identifier = this._getObjectSelfLink(object);

                // if this object is already possessed by another ajax element
                var identifierExists = identifier && this._requestsByUri.hasOwnProperty(identifier);
                if (identifierExists && this._objectMap[identifier] !== this) {
                    var ajax = this._objectMap[identifier];

                    if (ajax.lastResponse != null) {
                        // if the already known ajax instance has an object already update it with the new data
                        this._updateObject(object, index);
                        return ajax.lastResponse;
                    } else {
                        // if not, fake a request success and set the new object
                        // the ajax element will process it for us
                        ajax._setLastResponse(object);
                        return object;
                    }
                } else {
                    this._processProperties(object, index);
                    return object;
                }
            },

            _processProperties: function (object, index) {
                this._processEmbeddedProperties(object, index);
                this._processLinkProperties(object, index);
            },

            _getObjectSelfLink: function (object) {
                if (!object[this.linkProperty]) {
                    return null;
                }

                if (!object[this.linkProperty]['self']) {
                    return null;
                }

                return object[this.linkProperty]['self']['href'];
            },

            _pathToObject: function (index) {
                var path = 'lastResponse';
                if (index != null) {
                    path += '.' + index;
                }
                return path;
            },

            _hideProperty: function (object, property) {
                var value = object[property];

                delete object[property];
                this._defineHiddenProperty(object, property, {
                    enumerable: false,
                    configurable: false,
                    value: value
                });
            },

            _processEmbeddedProperties: function (object) {
                var embedded = object[this.embeddedProperty];
                if (!(embedded instanceof Object)) {
                    return;
                }

                // hide the property as it is not really a value
                this._hideProperty(object, this.embeddedProperty);

                Object.keys(embedded).forEach(function (embeddedProperty) {

                    // modify the object as if it were a response
                    var object = this._process(embedded[embeddedProperty]);

                    // don't overwrite anything
                    if (embeddedProperty in object) {
                        return;
                    }

                    this._defineHiddenProperty(object, embeddedProperty, {
                        enumerable: false,
                        configurable: true,
                        value: object
                    });
                }, this);
            },

            _processLinkProperties: function (object, index) {
                var links = object[this.linkProperty];
                if (!(links instanceof Object)) {
                    return;
                }

                // hide the property as it is not really a value
                this._hideProperty(object, this.linkProperty);

                Object.keys(links).forEach(function (linkProperty) {
                    // don't overwrite anything
                    if (linkProperty in object) {
                        return;
                    }

                    var attributes = links[linkProperty];
                    this._createLinkGetMethod(object, index, linkProperty, attributes);
                    this._createLinkPutMethod(object, index, linkProperty, attributes);
                    this._createLinkPostMethod(object, index, linkProperty, attributes);
                    this._createLinkDeleteMethod(object, index, linkProperty, attributes);

                    // special treatment for self
                    if (linkProperty === 'self') {
                        this._createSelfReloadMethod(object, index, attributes);
                    }
                }, this);
            },

            _defineHiddenProperty: function (object, propertyName, options) {
                var otherHiddenProperties = object.__hateoasProperties__;
                if (otherHiddenProperties == null) {
                    otherHiddenProperties = {};
                    Object.defineProperty(object, '__hateoasProperties__', {
                        enumerable: false,
                        value: otherHiddenProperties
                    });
                }

                options.enumerable = false;
                Object.defineProperty(object, propertyName, options);
                otherHiddenProperties[propertyName] = propertyName;
            },

            _attachAjaxGet: function (object, propertyName, attributes) {
                var ajaxStorageField = propertyName + 'GetRequest';

                var ajax = null;
                if (this._requestsByUri.hasOwnProperty(attributes.href)) {
                    ajax = this._requestsByUri[attributes.href];
                } else {
                    ajax = this.createSubInstance();
                    ajax.url = attributes.href;
                    ajax.method = 'get';
                    this._requestsByUri[attributes.href] = ajax;
                }

                this._defineHiddenProperty(object, ajaxStorageField, {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: ajax
                });

                return ajax;
            },

            /**
             * Updates all properties of an object with the new data.
             * All old data is removed in that process.
             *
             * This method only works with this.lastResponse and not any external things.
             *
             * @param newData
             * @param index
             * @private
             */
            _updateObject: function (newData, index) {
                var oldObject = this.get(this._pathToObject(index));

                if (oldObject.__hateoasProperties__ == null) {
                    console.error('__hateoasProperties__ missing on object', newData);
                    throw new Error("__hateoasProperties__ missing, way without not implemented");
                }

                // first delete everything that is visible or that we put there
                var propertiesToDelete = Object.keys(oldObject).concat(Object.keys(oldObject.__hateoasProperties__));
                propertiesToDelete.forEach(function (property) {
                    if (newData.hasOwnProperty(property)) {
                        return;
                    }
                    delete object[property];
                });
                delete newData.__hateoasProperties__;

                // now rebuild the object with the new data
                Object.keys(newData).forEach(function (value, property) {
                    // at this point this is still the raw json import so no special properties
                    // TODO check if the property value has changed
                    // TODO cast a notify or use the .set method
                    oldObject[property] = value;
                }, this);
                // then process them
                this._processProperties(oldObject, index);
            },

            _createSelfReloadMethod: function (object, index, attributes) {
                this._createLinkGetMethod(object, index, 'self', attributes);
                var ajaxStorageField = 'selfGetRequest';

                // expect the self method to always return a single object
                // that allows to make a few assumptions

                var replaceSelf = function (newValue) {

                    // set all new values
                    Object.keys(newValue.__hateoasProperties__).forEach(function (property) {
                        delete object[property];
                    });
                    // TODO continue
                };

                object[ajaxStorageField].addEventListener('last-response-changed', function () {

                });
            },

            _createLinkGetMethod: function (object, index, propertyName, attributes) {
                var self = this;
                var ajax = this._attachAjaxGet(object, propertyName, attributes);

                var fullObjectPath = this._pathToObject(index);
                fullObjectPath += '.' + propertyName;

                var replaceValue = function (newValue) {
                    self._defineHiddenProperty(object, propertyName, {
                        enumerable: false,
                        configurable: true,
                        value: newValue
                    });
                    self.notifyPath(fullObjectPath, newValue);
                };

                // replace by value after the request is done
                ajax.addEventListener('last-response-changed', function (e) {
                    if (e.detail.path == null || e.detail.path === 'lastResponse') {
                        replaceValue(e.detail.value);
                    } else {
                        // also forward changes within the response
                        var path = e.detail.path.replace('lastResponse', fullObjectPath);
                        self.notifyPath(path, e.detail.value);
                    }
                });

                // if there is already a response, just use it
                if (ajax.lastResponse != null) {
                    replaceValue(ajax.lastResponse);
                }

                // define a getter to trigger the request
                this._defineHiddenProperty(object, propertyName, {
                    enumerable: false,
                    configurable: true,

                    get: function () {
                        if (!ajax.loading) {
                            ajax.generateRequest();
                        }
                    },
                    set: function (value) {
                        if (ajax.loading) {
                            // if the property is explicitly set
                            // abort any request and set it directly
                            // the documentation tells about a discardRequest method but the real method is private
                            // fallback to the private method and use the documented one if present
                            var discardMethod = ajax.discardRequest || ajax._discardRequest;
                            discardMethod.call(ajax, ajax.lastRequest);
                        }

                        delete this[propertyName];
                        this[propertyName] = value;
                    }
                });

                // also define a way to load the values explicitly (this won't be overwritten after the request)
                var getMethodName = this._composeMethodName('get', propertyName);
                this._defineHiddenProperty(object, getMethodName, {
                    enumerable: false,
                    configurable: false,
                    value: function () {
                        if (!ajax.loading) {
                            ajax.generateRequest();
                        }
                        return ajax;
                    }
                });
            },

            _createLinkPostMethod: function (object, index, propertyName, attributes) {
                this._createLinkBodyMethod('post', object, propertyName, attributes);
            },

            _createLinkPutMethod: function (object, index, propertyName, attributes) {
                this._createLinkBodyMethod('put', object, propertyName, attributes);
            },

            _composeMethodName: function (method, propertyName) {
                return method + propertyName.substr(0, 1).toUpperCase() + propertyName.substr(1);
            },

            _createLinkBodyMethod: function (method, object, propertyName, attributes) {
                var methodName = this._composeMethodName(method, propertyName);
                var self = this;

                this._defineHiddenProperty(object, methodName, {
                    enumerable: false,
                    configurable: false,
                    value: function (data) {
                        var request = self.createSubInstance();
                        request.url = attributes.href;
                        request.method = method;
                        request.contentType = 'application/json';
                        request.body = JSON.stringify(data);
                        request.generateRequest();

                        return request;
                    }
                });
            },

            _createLinkDeleteMethod: function (object, index, name, attributes) {
                var methodName = this._composeMethodName('delete', name);
                var self = this;

                this._defineHiddenProperty(object, methodName, {
                    enumerable: false,
                    configurable: false,
                    value: function (data) {
                        var request = self.createSubInstance();
                        request.url = attributes.href;
                        request.method = 'delete';
                        request.params = data;
                        request.generateRequest();

                        return request;
                    }
                });
            }
        });
    </script>
</dom-module>